# ROS 2 کے بنیادی اصول

## ROS 2 کیا ہے؟

ROS (روبوٹ آپریٹنگ سسٹم) روبوٹس کے لیے ایک اوپن سورس، میٹا آپریٹنگ سسٹم ہے۔ یہ ایک لچکدار فریم ورک، اوزار، لائبریریاں، اور کنونشنز کا ایک مجموعہ فراہم کرتا ہے جو متنوع ہارڈویئر پلیٹ فارمز پر پیچیدہ اور مضبوط روبوٹ رویوں کو بنانے کے کام کو آسان بناتا ہے۔ ROS 2 تازہ ترین تکرار ہے، جسے جدید روبوٹکس ایپلی کیشنز کے ابھرتے ہوئے مطالبات کو پورا کرنے کے لیے انجنیئر کیا گیا ہے، بشمول حقیقی وقت کی کارکردگی، ملٹی روبوٹ سسٹمز کے لیے سپورٹ، اور ایمبیڈڈ پلیٹ فارمز پر تعیناتی۔ یہ ماڈیولر اور تقسیم شدہ روبوٹک سافٹ ویئر کی ترقی کو آسان بناتا ہے۔

### ROS 2 میں کلیدی تصورات:
*   **نوڈز**: ROS 2 میں حساب کی سب سے چھوٹی اکائی۔ نوڈز قابل عمل عمل ہیں جو ایک مخصوص کام انجام دیتے ہیں (جیسے، ایک سینسر ڈرائیور، ایک موٹر کنٹرولر، ایک نیویگیشن الگورتھم)۔ ایک پیچیدہ روبوٹ نظام بہت سے باہم مربوط نوڈز پر مشتمل ہوتا ہے۔
*   **ٹاپکس**: غیر مطابقت پذیر، پبلش/سبسکرائب پیغام رسانی کے لیے بنیادی میکانزم۔ نوڈز ٹاپکس پر ڈیٹا شائع کر سکتے ہیں (جیسے، سینسر ریڈنگز، کمانڈ ویلاسٹیز)، اور دوسرے نوڈز ڈیٹا حاصل کرنے کے لیے ان ٹاپکس کو سبسکرائب کر سکتے ہیں۔
*   **سروسز**: ایک مطابقت پذیر، درخواست/جواب مواصلاتی میکانزم۔ سروسز ان آپریشنز کے لیے استعمال ہوتی ہیں جن کے لیے فوری جواب کی ضرورت ہوتی ہے، جیسے کسی ایک ریڈنگ کے لیے سینسر سے استفسار کرنا یا کسی مخصوص کارروائی کو متحرک کرنا۔
*   **ایکشنز**: طویل عرصے تک چلنے والے، ہدف پر مبنی کاموں کے لیے ڈیزائن کیا گیا ہے جو متواتر فیڈ بیک فراہم کرتے ہیں اور انہیں پہلے سے خالی کیا جا سکتا ہے۔ مثالوں میں ہدف کے مقام پر نیویگیٹ کرنا یا ایک پیچیدہ ہیرا پھیری کی ترتیب انجام دینا شامل ہے۔
*   **پیغامات**: ڈیٹا ڈھانچے جو ٹاپکس، سروسز، اور ایکشنز پر تبادلہ ہونے والی معلومات کی اقسام کی وضاحت کرتے ہیں۔ ROS 2 معیاری پیغام کی اقسام کا ایک بھرپور سیٹ فراہم کرتا ہے، اور صارفین اپنی مرضی کے پیغامات کی وضاحت کر سکتے ہیں۔
*   **پیرامیٹرز**: کنفیگریشن ویلیوز جو نوڈز کے ذریعے متحرک طور پر سیٹ کی جا سکتی ہیں یا فائلوں سے لوڈ کی جا سکتی ہیں۔ وہ دوبارہ تالیف کے بغیر نوڈ کے رویے کی لچکدار ایڈجسٹمنٹ کی اجازت دیتے ہیں۔
*   **پیکجز**: ROS 2 کوڈ کو منظم کرنے کے لیے بنیادی اکائی۔ ایک پیکیج میں نوڈز، لائبریریاں، کنفیگریشن فائلیں، پیغام کی تعریفیں، اور دیگر متعلقہ وسائل شامل ہوتے ہیں۔
*   **ورک اسپیسز**: ڈائرکٹریاں جن میں متعدد ROS 2 پیکجز شامل ہوتے ہیں، جو متعلقہ منصوبوں کے آسان انتظام اور تعمیر کی اجازت دیتے ہیں۔

## ROS 2 کیوں؟

جدید روبوٹکس کی ترقی میں ROS 2 کی اہمیت کو بڑھا چڑھا کر پیش نہیں کیا جا سکتا۔ یہ ایک معیاری مواصلاتی انفراسٹرکچر اور اوزار، لائبریریوں، اور ڈرائیوروں کا ایک بھرپور ایکو سسٹم فراہم کرتا ہے جو پیچیدہ روبوٹک نظاموں کی ترقی اور تعیناتی کو نمایاں طور پر آسان بناتا ہے۔ اس کا ماڈیولر اور تقسیم شدہ ڈیزائن کوڈ کی دوبارہ استعمال کو فروغ دیتا ہے، عالمی روبوٹکس کمیونٹی کے اندر تعاون کو فروغ دیتا ہے، اور جدت کو تیز کرتا ہے۔ کم سطحی مواصلات اور ہارڈویئر تعامل کے زیادہ تر حصے کو خلاصہ کرکے، ROS 2 ڈویلپرز کو اعلی سطحی روبوٹک رویوں اور الگورتھم پر توجہ مرکوز کرنے کی اجازت دیتا ہے۔

## ROS 1 پر بنیادی خصوصیات اور بہتری:

ROS 2 اپنے پیشرو، ROS 1 سے ایک بڑی تعمیراتی تبدیلی تھی، جس نے عصری روبوٹکس کی ضروریات کو پورا کرنے کے لیے اہم اضافہ کیا:
*   **DDS (ڈیٹا ڈسٹری بیوشن سروس) انضمام**: ROS 2 اپنے بنیادی مواصلاتی مڈل ویئر کے طور پر DDS کا فائدہ اٹھاتا ہے۔ DDS ایک معیاری (OMG اسٹینڈرڈ) ڈیٹا سینٹرک پبلش/سبسکرائب پیغام رسانی کا نظام ہے جو اپنی حقیقی وقت کی کارکردگی، توسیع پذیری، اور وشوسنییتا کے لیے جانا جاتا ہے، جو ROS 2 کو مشن کے لیے اہم ایپلی کیشنز کے لیے موزوں بناتا ہے۔
*   **سروس کا معیار (QoS) پالیسیاں**: ڈویلپرز ٹاپکس اور ایکشنز کے لیے QoS پالیسیاں بتا سکتے ہیں، جو وشوسنییتا (جیسے، بہترین کوشش بمقابلہ قابل اعتماد)، استحکام (جیسے، عارضی مقامی بمقابلہ غیر مستحکم)، تاریخ (جیسے، آخری رکھیں بمقابلہ سب رکھیں)، اور زندہ دلی جیسے پہلوؤں کو کنٹرول کرتے ہیں۔ یہ مواصلاتی رویے پر عمدہ کنٹرول کی اجازت دیتا ہے۔
*   **ملٹی روبوٹ سپورٹ**: روبوٹس کے بیڑے کو سنبھالنے کے لیے شروع سے ڈیزائن کیا گیا، ROS 2 میں نیٹ ورک کی دریافت، نام کی جگہ کا انتظام، اور تقسیم شدہ وسائل کی تقسیم کے لیے خصوصیات شامل ہیں، جو پیچیدہ ملٹی روبوٹ کوآرڈینیشن کو ممکن بناتی ہیں۔
*   **سیکیورٹی**: ROS 2 SROS 2 (سیکیور ROS 2) کے ذریعے مضبوط سیکیورٹی خصوصیات کو شامل کرتا ہے، جو بین نوڈ مواصلات کے لیے تصدیق، اجازت، خفیہ کاری، اور ڈیٹا کی سالمیت فراہم کرتا ہے، جو صنعتی اور عوامی سامنا کرنے والی ایپلی کیشنز کے لیے اہم ہے۔
*   **حقیقی وقت کی صلاحیتیں**: اگرچہ خود ایک سخت حقیقی وقت کا آپریٹنگ سسٹم نہیں ہے، ROS 2 کو حقیقی وقت کی ضروریات کو مدنظر رکھتے ہوئے بنایا گیا ہے، جو RTOS کے موافق مواصلات اور ایگزیکیوٹر ماڈلز کا استعمال کرکے سخت وقتی ضمانتوں کا مطالبہ کرنے والی ایپلی کیشنز کے لیے بہتر سپورٹ پیش کرتا ہے۔
*   **پلیٹ فارم کی آزادی**: لینکس کے علاوہ آپریٹنگ سسٹمز کی ایک وسیع رینج کی حمایت کرتا ہے، بشمول ونڈوز اور میک او ایس، اس کی قابل اطلاق کو وسیع کرتا ہے۔
*   **زبان سے آزاد کلائنٹس**: C++ اور Python کے علاوہ متعدد زبانوں کے لیے کلائنٹ لائبریریاں فراہم کرتا ہے، جیسے جاوا اور C#، ترقیاتی لچک کو بڑھاتا ہے۔

**مثال: ROS 2 سروس کلائنٹ (Python)**

یہ مثال یہ ظاہر کرتی ہے کہ ایک سادہ ROS 2 سروس کلائنٹ کیسے بنایا جائے جو ایک درخواست بھیجتا ہے اور جواب کا انتظار کرتا ہے۔ ہم فرض کریں گے کہ ایک سروس دو انٹیجرز کو جوڑتی ہے۔

پہلے، سروس انٹرفیس کی وضاحت کریں (جیسے، `example_interfaces/srv/AddTwoInts.srv`):
```
# درخواست
int64 a
int64 b
---
# جواب
int64 sum
```

پھر، Python کلائنٹ نوڈ:

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts # سروس کی قسم درآمد کریں

class MinimalServiceClient(Node):
    def __init__(self):
        super().__init__('minimal_service_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('سروس دستیاب نہیں ہے، دوبارہ انتظار کر رہے ہیں...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        self.get_logger().info(f'درخواست بھیجی جا رہی ہے: a={a}, b={b}')

def main(args=None):
    rclpy.init(args=args)
    minimal_service_client = MinimalServiceClient()
    minimal_service_client.send_request(41, 1) # مثال کی قدریں

    while rclpy.ok():
        rclpy.spin_once(minimal_service_client)
        if minimal_service_client.future.done():
            try:
                response = minimal_service_client.future.result()
            except Exception as e:
                minimal_service_client.get_logger().error(f'سروس کال ناکام ہوگئی: {e}')
            else:
                minimal_service_client.get_logger().info(
                    f'add_two_ints کا نتیجہ: {minimal_service_client.req.a} + '
                    f'{minimal_service_client.req.b} = {response.sum}'
                )
            break
    
    minimal_service_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```
اس مثال کو چلانے کے لیے، آپ کو پہلے ایک متعلقہ ROS 2 سروس سرور چلانے کی ضرورت ہوگی (جیسے، `example_interfaces` پیکیج سے `add_two_ints_server`)، اور `example_interfaces` پیکیج آپ کے ماحول میں سورس کیا گیا ہو۔
